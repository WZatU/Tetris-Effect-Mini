<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>手势控制特效方块游戏</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/lucide@latest"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    import React, { useEffect, useRef, useState } from 'react';
    import { Camera, Hand, Zap, Volume2, VolumeX } from 'lucide-react';

    const GestureTetrisGame = () => {
      const canvasRef = useRef(null);
      const videoRef = useRef(null);
      const [cameraActive, setCameraActive] = useState(false);
      const [handDetected, setHandDetected] = useState(false);
      const [score, setScore] = useState(0);
      const [soundEnabled, setSoundEnabled] = useState(true);
      const gameRef = useRef(null);

      useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        canvas.width = 400;
        canvas.height = 600;

        // 游戏状态
        const game = {
          board: Array(20)
            .fill(null)
            .map(() => Array(10).fill(0)),
          currentPiece: null,
          particles: [],
          score: 0,
          colors: ['#FF006E', '#FB5607', '#FFBE0B', '#8338EC', '#3A86FF'],
          audioCtx: new (window.AudioContext || window.webkitAudioContext)(),
        };
        gameRef.current = game;

        // 俄罗斯方块形状
        const shapes = [
          [[1, 1, 1, 1]], // I
          [[1, 1], [1, 1]], // O
          [[0, 1, 0], [1, 1, 1]], // T
          [[1, 0, 0], [1, 1, 1]], // L
          [[0, 0, 1], [1, 1, 1]], // J
          [[0, 1, 1], [1, 1, 0]], // S
          [[1, 1, 0], [0, 1, 1]], // Z
        ];

        // 创建新方块
        function createPiece() {
          const shape = shapes[Math.floor(Math.random() * shapes.length)];
          const color = game.colors[Math.floor(Math.random() * game.colors.length)];
          return {
            shape,
            x: Math.floor((10 - shape[0].length) / 2),
            y: 0,
            color,
          };
        }

        // 粒子系统
        function createParticles(x, y, color) {
          for (let i = 0; i < 15; i++) {
            game.particles.push({
              x: x * 40 + 20,
              y: y * 30 + 15,
              vx: (Math.random() - 0.5) * 8,
              vy: (Math.random() - 0.5) * 8,
              life: 1,
              color,
              size: Math.random() * 6 + 2,
            });
          }
        }

        // 音效
        function playSound(frequency, duration) {
          if (!soundEnabled) return;
          const oscillator = game.audioCtx.createOscillator();
          const gainNode = game.audioCtx.createGain();
          oscillator.connect(gainNode);
          gainNode.connect(game.audioCtx.destination);
          oscillator.frequency.value = frequency;
          oscillator.type = 'sine';
          gainNode.gain.setValueAtTime(0.1, game.audioCtx.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(
            0.01,
            game.audioCtx.currentTime + duration
          );
          oscillator.start(game.audioCtx.currentTime);
          oscillator.stop(game.audioCtx.currentTime + duration);
        }

        // 碰撞检测
        function collides(piece, offsetX = 0, offsetY = 0) {
          for (let y = 0; y < piece.shape.length; y++) {
            for (let x = 0; x < piece.shape[y].length; x++) {
              if (piece.shape[y][x]) {
                const newX = piece.x + x + offsetX;
                const newY = piece.y + y + offsetY;
                if (newX < 0 || newX >= 10 || newY >= 20) return true;
                if (newY >= 0 && game.board[newY][newX]) return true;
              }
            }
          }
          return false;
        }

        // 固定方块
        function lockPiece(piece) {
          for (let y = 0; y < piece.shape.length; y++) {
            for (let x = 0; x < piece.shape[y].length; x++) {
              if (piece.shape[y][x]) {
                const boardY = piece.y + y;
                const boardX = piece.x + x;
                if (boardY >= 0) {
                  game.board[boardY][boardX] = piece.color;
                  createParticles(boardX, boardY, piece.color);
                }
              }
            }
          }
          checkLines();
          game.currentPiece = createPiece();
          if (collides(game.currentPiece)) {
            // 游戏结束
            game.board = Array(20)
              .fill(null)
              .map(() => Array(10).fill(0));
            game.score = 0;
            setScore(0);
          }
        }

        // 消除行
        function checkLines() {
          let linesCleared = 0;
          for (let y = game.board.length - 1; y >= 0; y--) {
            if (game.board[y].every((cell) => cell !== 0)) {
              game.board.splice(y, 1);
              game.board.unshift(Array(10).fill(0));
              linesCleared++;
              y++;
              playSound(523.25 + linesCleared * 100, 0.1);
            }
          }
          if (linesCleared > 0) {
            game.score += linesCleared * 100;
            setScore(game.score);
          }
        }

        // 旋转方块
        function rotatePiece() {
          const rotated = game.currentPiece.shape[0].map((_, i) =>
            game.currentPiece.shape.map((row) => row[i]).reverse()
          );
          const oldShape = game.currentPiece.shape;
          game.currentPiece.shape = rotated;
          if (collides(game.currentPiece)) {
            game.currentPiece.shape = oldShape;
          } else {
            playSound(440, 0.05);
          }
        }

        // 移动方块
        window.movePiece = (dx) => {
          if (game.currentPiece && !collides(game.currentPiece, dx, 0)) {
            game.currentPiece.x += dx;
            playSound(330, 0.03);
          }
        };

        window.dropPiece = () => {
          if (game.currentPiece) {
            while (!collides(game.currentPiece, 0, 1)) {
              game.currentPiece.y++;
            }
            lockPiece(game.currentPiece);
            playSound(220, 0.1);
          }
        };

        window.rotatePiece = rotatePiece;

        // 渲染
        function render() {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // 绘制背景网格效果
          ctx.strokeStyle = 'rgba(255,255,255,0.05)';
          ctx.lineWidth = 1;
          for (let i = 0; i < 10; i++) {
            ctx.beginPath();
            ctx.moveTo(i * 40, 0);
            ctx.lineTo(i * 40, 600);
            ctx.stroke();
          }
          for (let i = 0; i < 20; i++) {
            ctx.beginPath();
            ctx.moveTo(0, i * 30);
            ctx.lineTo(400, i * 30);
            ctx.stroke();
          }

          // 绘制已固定的方块
          for (let y = 0; y < game.board.length; y++) {
            for (let x = 0; x < game.board[y].length; x++) {
              if (game.board[y][x]) {
                ctx.fillStyle = game.board[y][x];
                ctx.shadowBlur = 20;
                ctx.shadowColor = game.board[y][x];
                ctx.fillRect(x * 40 + 2, y * 30 + 2, 36, 26);
                ctx.shadowBlur = 0;
              }
            }
          }

          // 绘制当前方块
          if (game.currentPiece) {
            ctx.fillStyle = game.currentPiece.color;
            ctx.shadowBlur = 30;
            ctx.shadowColor = game.currentPiece.color;
            for (let y = 0; y < game.currentPiece.shape.length; y++) {
              for (let x = 0; x < game.currentPiece.shape[y].length; x++) {
                if (game.currentPiece.shape[y][x]) {
                  ctx.fillRect(
                    (game.currentPiece.x + x) * 40 + 2,
                    (game.currentPiece.y + y) * 30 + 2,
                    36,
                    26
                  );
                }
              }
            }
            ctx.shadowBlur = 0;
          }

          // 绘制粒子
          game.particles = game.particles.filter((p) => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.3;
            p.life -= 0.02;
            if (p.life > 0) {
              ctx.fillStyle = p.color;
              ctx.globalAlpha = p.life;
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
              ctx.fill();
              ctx.globalAlpha = 1;
              return true;
            }
            return false;
          });
        }

        // 游戏循环
        let lastTime = 0;
        let dropCounter = 0;
        const dropInterval = 1000;

        function gameLoop(time = 0) {
          const deltaTime = time - lastTime;
          lastTime = time;
          dropCounter += deltaTime;

          if (dropCounter > dropInterval) {
            if (game.currentPiece) {
              if (!collides(game.currentPiece, 0, 1)) {
                game.currentPiece.y++;
              } else {
                lockPiece(game.currentPiece);
              }
            }
            dropCounter = 0;
          }

          render();
          requestAnimationFrame(gameLoop);
        }

        game.currentPiece = createPiece();
        gameLoop();

        // 键盘控制
        const handleKeyDown = (e) => {
          if (e.key === 'ArrowLeft') window.movePiece(-1);
          if (e.key === 'ArrowRight') window.movePiece(1);
          if (e.key === 'ArrowDown') window.dropPiece();
          if (e.key === 'ArrowUp') window.rotatePiece();
        };
        window.addEventListener('keydown', handleKeyDown);

        return () => {
          window.removeEventListener('keydown', handleKeyDown);
        };
      }, [soundEnabled]);

      // 手势识别
      const startCamera = async () => {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 640, height: 480 },
          });
          videoRef.current.srcObject = stream;
          await videoRef.current.play();
          setCameraActive(true);

          // 加载MediaPipe Hands
          const script = document.createElement('script');
          script.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js';
          script.onload = () => initHandTracking();
          document.body.appendChild(script);
        } catch (err) {
          alert('无法访问摄像头: ' + err.message);
        }
      };

      const initHandTracking = () => {
        const hands = new window.Hands({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
        });

        hands.setOptions({
          maxNumHands: 1,
          modelComplexity: 1,
          minDetectionConfidence: 0.5,
          minTrackingConfidence: 0.5,
        });

        let lastX = null;
        let lastGesture = null;

        hands.onResults((results) => {
          if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            setHandDetected(true);
            const landmarks = results.multiHandLandmarks[0];
            const wrist = landmarks[0];
            const indexTip = landmarks[8];
            const thumbTip = landmarks[4];

            // 手掌X位置控制左右移动
            const currentX = wrist.x;
            if (lastX !== null) {
              const diff = currentX - lastX;
              if (Math.abs(diff) > 0.08) {
                window.movePiece(diff > 0 ? 1 : -1);
                lastX = currentX;
              }
            } else {
              lastX = currentX;
            }

            // 捏合手势 = 快速下落
            const distance = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
            if (distance < 0.05 && lastGesture !== 'pinch') {
              window.dropPiece();
              lastGesture = 'pinch';
            } else if (distance > 0.1) {
              lastGesture = null;
            }

            // 手掌高度变化 = 旋转
            if (wrist.y < 0.3 && lastGesture !== 'up') {
              window.rotatePiece();
              lastGesture = 'up';
            } else if (wrist.y > 0.4) {
              lastGesture = null;
            }
          } else {
            setHandDetected(false);
            lastX = null;
          }
        });

        const camera = new window.Camera(videoRef.current, {
          onFrame: async () => {
            await hands.send({ image: videoRef.current });
          },
          width: 640,
          height: 480,
        });
        camera.start();
      };

      return (
        <div className="min-h-screen bg-gray-900 flex items-center justify-center p-4">
          <div className="max-w-6xl w-full">
            <div className="text-center mb-6">
              <h1 className="text-4xl font-bold text-white mb-2">手势控制特效方块游戏</h1>
              <p className="text-gray-400">键盘: ←→ 移动 | ↑ 旋转 | ↓ 快速下落</p>
              <p className="text-gray-400">手势: 左右移动手掌 | 手掌上举旋转 | 捏合快速下落</p>
            </div>

            <div className="flex flex-col lg:flex-row gap-6 items-start justify-center">
              {/* 游戏画布 */}
              <div className="relative">
                <canvas
                  ref={canvasRef}
                  className="border-4 border-purple-500 rounded-lg shadow-2xl"
                  style={{ boxShadow: '0 0 50px rgba(139, 92, 246, 0.5)' }}
                />
                <div className="absolute top-4 left-4 bg-black bg-opacity-70 px-4 py-2 rounded">
                  <div className="text-yellow-400 text-2xl font-bold">得分: {score}</div>
                </div>
                <div className="absolute top-4 right-4 flex gap-2">
                  <button
                    onClick={() => setSoundEnabled(!soundEnabled)}
                    className="bg-black bg-opacity-70 p-2 rounded hover:bg-opacity-90"
                  >
                    {soundEnabled ? <Volume2 className="text-green-400" size={24} /> : <VolumeX className="text-red-400" size={24} />}
                  </button>
                </div>
              </div>

              {/* 摄像头控制 */}
              <div className="bg-gray-800 rounded-lg p-6 w-full lg:w-96">
                <h2 className="text-white text-xl font-bold mb-4 flex items-center gap-2">
                  <Hand className="text-purple-400" />
                  手势控制
                </h2>

                {!cameraActive ? (
                  <button
                    onClick={startCamera}
                    className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg flex items-center justify-center gap-2 transition"
                  >
                    <Camera size={24} />
                    启动摄像头
                  </button>
                ) : (
                  <div>
                    <video
                      ref={videoRef}
                      className="w-full rounded-lg mb-4"
                      style={{ transform: 'scaleX(-1)' }}
                    />
                    <div
                      className={`flex items-center gap-2 p-3 rounded ${handDetected ? 'bg-green-900' : 'bg-red-900'}`}
                    >
                      <Zap className={handDetected ? 'text-green-400' : 'text-red-400'} />
                      <span className="text-white">{handDetected ? '手势已识别' : '未检测到手势'}</span>
                    </div>
                  </div>
                )}

                <div className="mt-6 text-gray-300 text-sm space-y-2">
                  <p className="font-bold text-white">手势说明:</p>
                  <p>• 左右移动手掌 → 方块左右移动</p>
                  <p>• 手掌上举 → 旋转方块</p>
                  <p>• 捏合手指 → 快速下落</p>
                </div>
              </div>
            </div>

            <div className="mt-8 text-center text-gray-400 text-sm">
              <p>使用 Three.js, MediaPipe Hands 和 Web Audio API 构建</p>
              <p className="mt-2">提示: 确保光线充足以获得最佳手势识别效果</p>
            </div>
          </div>
        </div>
      );
    };

    const rootEl = ReactDOM.createRoot(document.getElementById('root'));
    rootEl.render(<GestureTetrisGame />);
  </script>
</body>
</html>
