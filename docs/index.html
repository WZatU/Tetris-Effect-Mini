<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>手势控制特效方块游戏</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const GestureTetrisGame = () => {
      const canvasRef = useRef(null);
      const videoRef = useRef(null);
      const [cameraActive, setCameraActive] = useState(false);
      const [handDetected, setHandDetected] = useState(false);
      const [score, setScore] = useState(0);
      const [soundEnabled, setSoundEnabled] = useState(true);
      const [cameraError, setCameraError] = useState('');
      const gameRef = useRef(null);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        canvas.width = 400;
        canvas.height = 600;

        const game = {
          board: Array(20).fill(null).map(() => Array(10).fill(0)),
          currentPiece: null,
          particles: [],
          score: 0,
          colors: ['#FF006E', '#FB5607', '#FFBE0B', '#8338EC', '#3A86FF'],
          audioCtx: null,
        };
        
        // 延迟初始化 AudioContext
        try {
          game.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
          console.log('AudioContext not available');
        }
        
        gameRef.current = game;

        const shapes = [
          [[1, 1, 1, 1]], [[1, 1], [1, 1]], [[0, 1, 0], [1, 1, 1]], 
          [[1, 0, 0], [1, 1, 1]], [[0, 0, 1], [1, 1, 1]], 
          [[0, 1, 1], [1, 1, 0]], [[1, 1, 0], [0, 1, 1]]
        ];

        function createPiece() {
          const shape = shapes[Math.floor(Math.random() * shapes.length)];
          const color = game.colors[Math.floor(Math.random() * game.colors.length)];
          return { shape, x: Math.floor((10 - shape[0].length) / 2), y: 0, color };
        }

        function createParticles(x, y, color) {
          for (let i = 0; i < 15; i++) {
            game.particles.push({
              x: x * 40 + 20, y: y * 30 + 15,
              vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
              life: 1, color, size: Math.random() * 6 + 2
            });
          }
        }

        function playSound(frequency, duration) {
          if (!soundEnabled || !game.audioCtx) return;
          try {
            const osc = game.audioCtx.createOscillator();
            const gain = game.audioCtx.createGain();
            osc.connect(gain);
            gain.connect(game.audioCtx.destination);
            osc.frequency.value = frequency;
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.1, game.audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, game.audioCtx.currentTime + duration);
            osc.start(game.audioCtx.currentTime);
            osc.stop(game.audioCtx.currentTime + duration);
          } catch (e) {
            console.log('Sound error:', e);
          }
        }

        function collides(piece, offsetX = 0, offsetY = 0) {
          for (let y = 0; y < piece.shape.length; y++) {
            for (let x = 0; x < piece.shape[y].length; x++) {
              if (piece.shape[y][x]) {
                const newX = piece.x + x + offsetX;
                const newY = piece.y + y + offsetY;
                if (newX < 0 || newX >= 10 || newY >= 20) return true;
                if (newY >= 0 && game.board[newY][newX]) return true;
              }
            }
          }
          return false;
        }

        function lockPiece(piece) {
          for (let y = 0; y < piece.shape.length; y++) {
            for (let x = 0; x < piece.shape[y].length; x++) {
              if (piece.shape[y][x]) {
                const boardY = piece.y + y;
                const boardX = piece.x + x;
                if (boardY >= 0) {
                  game.board[boardY][boardX] = piece.color;
                  createParticles(boardX, boardY, piece.color);
                }
              }
            }
          }
          checkLines();
          game.currentPiece = createPiece();
          if (collides(game.currentPiece)) {
            game.board = Array(20).fill(null).map(() => Array(10).fill(0));
            game.score = 0;
            setScore(0);
          }
        }

        function checkLines() {
          let linesCleared = 0;
          for (let y = game.board.length - 1; y >= 0; y--) {
            if (game.board[y].every((cell) => cell !== 0)) {
              game.board.splice(y, 1);
              game.board.unshift(Array(10).fill(0));
              linesCleared++;
              y++;
              playSound(523.25 + linesCleared * 100, 0.1);
            }
          }
          if (linesCleared > 0) {
            game.score += linesCleared * 100;
            setScore(game.score);
          }
        }

        function rotatePiece() {
          if (!game.currentPiece) return;
          const rotated = game.currentPiece.shape[0].map((_, i) =>
            game.currentPiece.shape.map((row) => row[i]).reverse()
          );
          const oldShape = game.currentPiece.shape;
          game.currentPiece.shape = rotated;
          if (collides(game.currentPiece)) {
            game.currentPiece.shape = oldShape;
          } else {
            playSound(440, 0.05);
          }
        }

        window.movePiece = (dx) => {
          if (game.currentPiece && !collides(game.currentPiece, dx, 0)) {
            game.currentPiece.x += dx;
            playSound(330, 0.03);
          }
        };

        window.dropPiece = () => {
          if (game.currentPiece) {
            while (!collides(game.currentPiece, 0, 1)) {
              game.currentPiece.y++;
            }
            lockPiece(game.currentPiece);
            playSound(220, 0.1);
          }
        };

        window.rotatePiece = rotatePiece;

        function render() {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.strokeStyle = 'rgba(255,255,255,0.05)';
          ctx.lineWidth = 1;
          for (let i = 0; i < 10; i++) {
            ctx.beginPath();
            ctx.moveTo(i * 40, 0);
            ctx.lineTo(i * 40, 600);
            ctx.stroke();
          }
          for (let i = 0; i < 20; i++) {
            ctx.beginPath();
            ctx.moveTo(0, i * 30);
            ctx.lineTo(400, i * 30);
            ctx.stroke();
          }

          for (let y = 0; y < game.board.length; y++) {
            for (let x = 0; x < game.board[y].length; x++) {
              if (game.board[y][x]) {
                ctx.fillStyle = game.board[y][x];
                ctx.shadowBlur = 20;
                ctx.shadowColor = game.board[y][x];
                ctx.fillRect(x * 40 + 2, y * 30 + 2, 36, 26);
                ctx.shadowBlur = 0;
              }
            }
          }

          if (game.currentPiece) {
            ctx.fillStyle = game.currentPiece.color;
            ctx.shadowBlur = 30;
            ctx.shadowColor = game.currentPiece.color;
            for (let y = 0; y < game.currentPiece.shape.length; y++) {
              for (let x = 0; x < game.currentPiece.shape[y].length; x++) {
                if (game.currentPiece.shape[y][x]) {
                  ctx.fillRect(
                    (game.currentPiece.x + x) * 40 + 2,
                    (game.currentPiece.y + y) * 30 + 2,
                    36, 26
                  );
                }
              }
            }
            ctx.shadowBlur = 0;
          }

          game.particles = game.particles.filter((p) => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.3;
            p.life -= 0.02;
            if (p.life > 0) {
              ctx.fillStyle = p.color;
              ctx.globalAlpha = p.life;
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
              ctx.fill();
              ctx.globalAlpha = 1;
              return true;
            }
            return false;
          });
        }

        let lastTime = 0;
        let dropCounter = 0;
        const dropInterval = 1000;

        function gameLoop(time = 0) {
          const deltaTime = time - lastTime;
          lastTime = time;
          dropCounter += deltaTime;

          if (dropCounter > dropInterval) {
            if (game.currentPiece) {
              if (!collides(game.currentPiece, 0, 1)) {
                game.currentPiece.y++;
              } else {
                lockPiece(game.currentPiece);
              }
            }
            dropCounter = 0;
          }

          render();
          requestAnimationFrame(gameLoop);
        }

        game.currentPiece = createPiece();
        gameLoop();

        const handleKeyDown = (e) => {
          if (e.key === 'ArrowLeft') window.movePiece(-1);
          if (e.key === 'ArrowRight') window.movePiece(1);
          if (e.key === 'ArrowDown') window.dropPiece();
          if (e.key === 'ArrowUp') window.rotatePiece();
        };
        window.addEventListener('keydown', handleKeyDown);

        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [soundEnabled]);

      const startCamera = async () => {
        setCameraError('');
        try {
          // 检查是否支持getUserMedia
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('您的浏览器不支持摄像头访问');
          }

          const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 640, height: 480 },
          });
          
          if (videoRef.current) {
            videoRef.current.srcObject = stream;
            videoRef.current.onloadedmetadata = () => {
              videoRef.current.play().then(() => {
                setCameraActive(true);
                initHandTracking();
              }).catch(err => {
                setCameraError('视频播放失败: ' + err.message);
              });
            };
          }
        } catch (err) {
          console.error('Camera error:', err);
          setCameraError('摄像头访问失败: ' + err.message);
        }
      };

      const initHandTracking = () => {
        if (!window.Hands || !window.Camera) {
          setCameraError('MediaPipe库加载失败，手势识别不可用');
          return;
        }

        try {
          const hands = new window.Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
          });

          hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5,
          });

          let lastX = null;
          let lastGesture = null;

          hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
              setHandDetected(true);
              const landmarks = results.multiHandLandmarks[0];
              const wrist = landmarks[0];
              const indexTip = landmarks[8];
              const thumbTip = landmarks[4];

              const currentX = wrist.x;
              if (lastX !== null) {
                const diff = currentX - lastX;
                if (Math.abs(diff) > 0.08) {
                  window.movePiece(diff > 0 ? 1 : -1);
                  lastX = currentX;
                }
              } else {
                lastX = currentX;
              }

              const distance = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
              if (distance < 0.05 && lastGesture !== 'pinch') {
                window.dropPiece();
                lastGesture = 'pinch';
              } else if (distance > 0.1) {
                lastGesture = null;
              }

              if (wrist.y < 0.3 && lastGesture !== 'up') {
                window.rotatePiece();
                lastGesture = 'up';
              } else if (wrist.y > 0.4) {
                lastGesture = null;
              }
            } else {
              setHandDetected(false);
              lastX = null;
            }
          });

          if (videoRef.current) {
            const camera = new window.Camera(videoRef.current, {
              onFrame: async () => {
                if (videoRef.current) {
                  await hands.send({ image: videoRef.current });
                }
              },
              width: 640,
              height: 480,
            });
            camera.start();
          }
        } catch (err) {
          console.error('Hand tracking error:', err);
          setCameraError('手势识别初始化失败');
        }
      };

      // SVG 图标组件
      const CameraIcon = () => (
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
          <path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/>
          <circle cx="12" cy="13" r="3"/>
        </svg>
      );

      const HandIcon = () => (
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
          <path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0"/>
          <path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2"/>
          <path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8"/>
          <path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/>
        </svg>
      );

      const ZapIcon = () => (
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
          <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/>
        </svg>
      );

      const Volume2Icon = () => (
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
          <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
          <path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>
          <path d="M19.07 4.93a10 10 0 0 1 0 14.14"/>
        </svg>
      );

      const VolumeXIcon = () => (
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
          <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
          <line x1="23" y1="9" x2="17" y2="15"/>
          <line x1="17" y1="9" x2="23" y2="15"/>
        </svg>
      );

      return (
        <div className="min-h-screen bg-gray-900 flex items-center justify-center p-4">
          <div className="max-w-6xl w-full">
            <div className="text-center mb-6">
              <h1 className="text-4xl font-bold text-white mb-2">手势控制特效方块游戏</h1>
              <p className="text-gray-400">键盘: ←→ 移动 | ↑ 旋转 | ↓ 快速下落</p>
              <p className="text-gray-400">手势: 左右移动手掌 | 手掌上举旋转 | 捏合快速下落</p>
            </div>

            <div className="flex flex-col lg:flex-row gap-6 items-start justify-center">
              <div className="relative">
                <canvas
                  ref={canvasRef}
                  className="border-4 border-purple-500 rounded-lg shadow-2xl"
                  style={{ boxShadow: '0 0 50px rgba(139, 92, 246, 0.5)' }}
                />
                <div className="absolute top-4 left-4 bg-black bg-opacity-70 px-4 py-2 rounded">
                  <div className="text-yellow-400 text-2xl font-bold">得分: {score}</div>
                </div>
                <div className="absolute top-4 right-4 flex gap-2">
                  <button
                    onClick={() => setSoundEnabled(!soundEnabled)}
                    className="bg-black bg-opacity-70 p-2 rounded hover:bg-opacity-90"
                  >
                    {soundEnabled ? 
                      <Volume2Icon /> : 
                      <VolumeXIcon />
                    }
                  </button>
                </div>
              </div>

              <div className="bg-gray-800 rounded-lg p-6 w-full lg:w-96">
                <h2 className="text-white text-xl font-bold mb-4 flex items-center gap-2">
                  <HandIcon />
                  手势控制
                </h2>

                {!cameraActive ? (
                  <div>
                    <button
                      onClick={startCamera}
                      className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg flex items-center justify-center gap-2 transition"
                    >
                      <CameraIcon />
                      启动摄像头
                    </button>
                    {cameraError && (
                      <div className="mt-4 p-3 bg-red-900 bg-opacity-50 rounded text-red-200 text-sm">
                        {cameraError}
                      </div>
                    )}
                  </div>
                ) : (
                  <div>
                    <video
                      ref={videoRef}
                      className="w-full rounded-lg mb-4"
                      style={{ transform: 'scaleX(-1)' }}
                      playsInline
                      muted
                    />
                    <div className={`flex items-center gap-2 p-3 rounded ${handDetected ? 'bg-green-900' : 'bg-red-900'}`}>
                      <ZapIcon />
                      <span className="text-white">{handDetected ? '手势已识别' : '未检测到手势'}</span>
                    </div>
                  </div>
                )}

                <div className="mt-6 text-gray-300 text-sm space-y-2">
                  <p className="font-bold text-white">手势说明:</p>
                  <p>• 左右移动手掌 → 方块左右移动</p>
                  <p>• 手掌上举 → 旋转方块</p>
                  <p>• 捏合手指 → 快速下落</p>
                </div>
              </div>
            </div>

            <div className="mt-8 text-center text-gray-400 text-sm">
              <p>使用 React, MediaPipe Hands 和 Web Audio API 构建</p>
              <p className="mt-2">提示: 确保光线充足以获得最佳手势识别效果</p>
            </div>
          </div>
        </div>
      );
    };

    ReactDOM.render(<GestureTetrisGame />, document.getElementById('root'));
  </script>
</body>
</html>
