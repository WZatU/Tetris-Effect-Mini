<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>æ‰‹åŠ¿æ§åˆ¶ç‰¹æ•ˆæ–¹å—æ¸¸æˆ</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const GestureTetrisGame = () => {
      const canvasRef = useRef(null);
      const videoRef = useRef(null);
      const overlayCanvasRef = useRef(null);
      const [cameraActive, setCameraActive] = useState(false);
      const [handDetected, setHandDetected] = useState(false);
      const [score, setScore] = useState(0);
      const [soundEnabled, setSoundEnabled] = useState(true);
      const [cameraError, setCameraError] = useState('');
      const [currentGesture, setCurrentGesture] = useState('ç­‰å¾…æ‰‹åŠ¿...');
      const [gestureColor, setGestureColor] = useState('#666');
      const gameRef = useRef(null);

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        canvas.width = 400;
        canvas.height = 600;

        const game = {
          board: Array(20).fill(null).map(() => Array(10).fill(0)),
          currentPiece: null,
          particles: [],
          score: 0,
          colors: ['#FF006E', '#FB5607', '#FFBE0B', '#8338EC', '#3A86FF'],
          audioCtx: null,
        };
        
        try {
          game.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
          console.log('AudioContext not available');
        }
        
        gameRef.current = game;

        const shapes = [
          [[1, 1, 1, 1]], [[1, 1], [1, 1]], [[0, 1, 0], [1, 1, 1]], 
          [[1, 0, 0], [1, 1, 1]], [[0, 0, 1], [1, 1, 1]], 
          [[0, 1, 1], [1, 1, 0]], [[1, 1, 0], [0, 1, 1]]
        ];

        function createPiece() {
          const shape = shapes[Math.floor(Math.random() * shapes.length)];
          const color = game.colors[Math.floor(Math.random() * game.colors.length)];
          return { shape, x: Math.floor((10 - shape[0].length) / 2), y: 0, color };
        }

        function createParticles(x, y, color) {
          for (let i = 0; i < 15; i++) {
            game.particles.push({
              x: x * 40 + 20, y: y * 30 + 15,
              vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
              life: 1, color, size: Math.random() * 6 + 2
            });
          }
        }

        function playSound(frequency, duration) {
          if (!soundEnabled || !game.audioCtx) return;
          try {
            const osc = game.audioCtx.createOscillator();
            const gain = game.audioCtx.createGain();
            osc.connect(gain);
            gain.connect(game.audioCtx.destination);
            osc.frequency.value = frequency;
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.1, game.audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, game.audioCtx.currentTime + duration);
            osc.start(game.audioCtx.currentTime);
            osc.stop(game.audioCtx.currentTime + duration);
          } catch (e) {
            console.log('Sound error:', e);
          }
        }

        function collides(piece, offsetX = 0, offsetY = 0) {
          for (let y = 0; y < piece.shape.length; y++) {
            for (let x = 0; x < piece.shape[y].length; x++) {
              if (piece.shape[y][x]) {
                const newX = piece.x + x + offsetX;
                const newY = piece.y + y + offsetY;
                if (newX < 0 || newX >= 10 || newY >= 20) return true;
                if (newY >= 0 && game.board[newY][newX]) return true;
              }
            }
          }
          return false;
        }

        function lockPiece(piece) {
          for (let y = 0; y < piece.shape.length; y++) {
            for (let x = 0; x < piece.shape[y].length; x++) {
              if (piece.shape[y][x]) {
                const boardY = piece.y + y;
                const boardX = piece.x + x;
                if (boardY >= 0) {
                  game.board[boardY][boardX] = piece.color;
                  createParticles(boardX, boardY, piece.color);
                }
              }
            }
          }
          checkLines();
          game.currentPiece = createPiece();
          if (collides(game.currentPiece)) {
            game.board = Array(20).fill(null).map(() => Array(10).fill(0));
            game.score = 0;
            setScore(0);
          }
        }

        function checkLines() {
          let linesCleared = 0;
          for (let y = game.board.length - 1; y >= 0; y--) {
            if (game.board[y].every((cell) => cell !== 0)) {
              game.board.splice(y, 1);
              game.board.unshift(Array(10).fill(0));
              linesCleared++;
              y++;
              playSound(523.25 + linesCleared * 100, 0.1);
            }
          }
          if (linesCleared > 0) {
            game.score += linesCleared * 100;
            setScore(game.score);
          }
        }

        function rotatePiece() {
          if (!game.currentPiece) return;
          const rotated = game.currentPiece.shape[0].map((_, i) =>
            game.currentPiece.shape.map((row) => row[i]).reverse()
          );
          const oldShape = game.currentPiece.shape;
          game.currentPiece.shape = rotated;
          if (collides(game.currentPiece)) {
            game.currentPiece.shape = oldShape;
          } else {
            playSound(440, 0.05);
          }
        }

        window.movePiece = (dx) => {
          if (game.currentPiece && !collides(game.currentPiece, dx, 0)) {
            game.currentPiece.x += dx;
            playSound(330, 0.03);
          }
        };

        window.dropPiece = () => {
          if (game.currentPiece) {
            while (!collides(game.currentPiece, 0, 1)) {
              game.currentPiece.y++;
            }
            lockPiece(game.currentPiece);
            playSound(220, 0.1);
          }
        };

        window.rotatePiece = rotatePiece;

        function render() {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.strokeStyle = 'rgba(255,255,255,0.05)';
          ctx.lineWidth = 1;
          for (let i = 0; i < 10; i++) {
            ctx.beginPath();
            ctx.moveTo(i * 40, 0);
            ctx.lineTo(i * 40, 600);
            ctx.stroke();
          }
          for (let i = 0; i < 20; i++) {
            ctx.beginPath();
            ctx.moveTo(0, i * 30);
            ctx.lineTo(400, i * 30);
            ctx.stroke();
          }

          for (let y = 0; y < game.board.length; y++) {
            for (let x = 0; x < game.board[y].length; x++) {
              if (game.board[y][x]) {
                ctx.fillStyle = game.board[y][x];
                ctx.shadowBlur = 20;
                ctx.shadowColor = game.board[y][x];
                ctx.fillRect(x * 40 + 2, y * 30 + 2, 36, 26);
                ctx.shadowBlur = 0;
              }
            }
          }

          if (game.currentPiece) {
            ctx.fillStyle = game.currentPiece.color;
            ctx.shadowBlur = 30;
            ctx.shadowColor = game.currentPiece.color;
            for (let y = 0; y < game.currentPiece.shape.length; y++) {
              for (let x = 0; x < game.currentPiece.shape[y].length; x++) {
                if (game.currentPiece.shape[y][x]) {
                  ctx.fillRect(
                    (game.currentPiece.x + x) * 40 + 2,
                    (game.currentPiece.y + y) * 30 + 2,
                    36, 26
                  );
                }
              }
            }
            ctx.shadowBlur = 0;
          }

          game.particles = game.particles.filter((p) => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.3;
            p.life -= 0.02;
            if (p.life > 0) {
              ctx.fillStyle = p.color;
              ctx.globalAlpha = p.life;
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
              ctx.fill();
              ctx.globalAlpha = 1;
              return true;
            }
            return false;
          });
        }

        let lastTime = 0;
        let dropCounter = 0;
        const dropInterval = 1000;

        function gameLoop(time = 0) {
          const deltaTime = time - lastTime;
          lastTime = time;
          dropCounter += deltaTime;

          if (dropCounter > dropInterval) {
            if (game.currentPiece) {
              if (!collides(game.currentPiece, 0, 1)) {
                game.currentPiece.y++;
              } else {
                lockPiece(game.currentPiece);
              }
            }
            dropCounter = 0;
          }

          render();
          requestAnimationFrame(gameLoop);
        }

        game.currentPiece = createPiece();
        gameLoop();

        const handleKeyDown = (e) => {
          if (e.key === 'ArrowLeft') window.movePiece(-1);
          if (e.key === 'ArrowRight') window.movePiece(1);
          if (e.key === 'ArrowDown') window.dropPiece();
          if (e.key === 'ArrowUp') window.rotatePiece();
        };
        window.addEventListener('keydown', handleKeyDown);

        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [soundEnabled]);

      const startCamera = async () => {
        setCameraError('');
        try {
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®');
          }

          const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 640, height: 480 },
          });
          
          if (videoRef.current) {
            videoRef.current.srcObject = stream;
            videoRef.current.onloadedmetadata = () => {
              videoRef.current.play().then(() => {
                setCameraActive(true);
                // è®¾ç½® overlay canvas å°ºå¯¸
                if (overlayCanvasRef.current) {
                  overlayCanvasRef.current.width = 640;
                  overlayCanvasRef.current.height = 480;
                }
                initHandTracking();
              }).catch(err => {
                setCameraError('è§†é¢‘æ’­æ”¾å¤±è´¥: ' + err.message);
              });
            };
          }
        } catch (err) {
          console.error('Camera error:', err);
          setCameraError('æ‘„åƒå¤´è®¿é—®å¤±è´¥: ' + err.message);
        }
      };

      const initHandTracking = () => {
        if (!window.Hands || !window.Camera) {
          setCameraError('MediaPipeåº“åŠ è½½å¤±è´¥ï¼Œæ‰‹åŠ¿è¯†åˆ«ä¸å¯ç”¨');
          return;
        }

        try {
          const hands = new window.Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
          });

          hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5,
          });

          let lastX = null;
          let lastGesture = null;
          const overlayCanvas = overlayCanvasRef.current;
          const overlayCtx = overlayCanvas?.getContext('2d');

          hands.onResults((results) => {
            // æ¸…é™¤ overlay canvas
            if (overlayCtx) {
              overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            }

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
              setHandDetected(true);
              const landmarks = results.multiHandLandmarks[0];
              const wrist = landmarks[0];
              const indexTip = landmarks[8];
              const thumbTip = landmarks[4];

              // ç»˜åˆ¶æ‰‹éƒ¨éª¨æ¶
              if (overlayCtx && window.drawConnectors && window.drawLandmarks) {
                // ç»˜åˆ¶è¿çº¿
                window.drawConnectors(overlayCtx, landmarks, window.HAND_CONNECTIONS, {
                  color: '#00FF00',
                  lineWidth: 3
                });
                // ç»˜åˆ¶å…³é”®ç‚¹
                window.drawLandmarks(overlayCtx, landmarks, {
                  color: '#FF0000',
                  lineWidth: 1,
                  radius: 4
                });
              }

              // è®¡ç®—æ‰‹éƒ¨è¾¹ç•Œæ¡†
              let minX = 1, minY = 1, maxX = 0, maxY = 0;
              landmarks.forEach(lm => {
                minX = Math.min(minX, lm.x);
                minY = Math.min(minY, lm.y);
                maxX = Math.max(maxX, lm.x);
                maxY = Math.max(maxY, lm.y);
              });

              const boxX = minX * overlayCanvas.width;
              const boxY = minY * overlayCanvas.height;
              const boxW = (maxX - minX) * overlayCanvas.width;
              const boxH = (maxY - minY) * overlayCanvas.height;

              // æ£€æµ‹æ‰‹åŠ¿å¹¶è®¾ç½®é¢œè‰²
              let gestureDetected = 'å¾…æœº';
              let boxColor = '#00FF00'; // ç»¿è‰² - å¾…æœº

              const currentX = wrist.x;
              if (lastX !== null) {
                const diff = currentX - lastX;
                if (Math.abs(diff) > 0.08) {
                  if (diff > 0) {
                    gestureDetected = 'å‘å³ç§»åŠ¨';
                    boxColor = '#0088FF'; // è“è‰²
                  } else {
                    gestureDetected = 'å‘å·¦ç§»åŠ¨';
                    boxColor = '#FF8800'; // æ©™è‰²
                  }
                  window.movePiece(diff > 0 ? 1 : -1);
                  lastX = currentX;
                }
              } else {
                lastX = currentX;
              }

              const distance = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
              if (distance < 0.05 && lastGesture !== 'pinch') {
                gestureDetected = 'å¿«é€Ÿä¸‹è½';
                boxColor = '#FF00FF'; // ç´«è‰²
                window.dropPiece();
                lastGesture = 'pinch';
              } else if (distance > 0.1) {
                lastGesture = null;
              }

              if (wrist.y < 0.3 && lastGesture !== 'up') {
                gestureDetected = 'æ—‹è½¬æ–¹å—';
                boxColor = '#FFFF00'; // é»„è‰²
                window.rotatePiece();
                lastGesture = 'up';
              } else if (wrist.y > 0.4 && lastGesture === 'up') {
                lastGesture = null;
              }

              // ç»˜åˆ¶è¾¹ç•Œæ¡†
              if (overlayCtx) {
                overlayCtx.strokeStyle = boxColor;
                overlayCtx.lineWidth = 4;
                overlayCtx.strokeRect(boxX - 10, boxY - 10, boxW + 20, boxH + 20);
                
                // ç»˜åˆ¶æ‰‹åŠ¿æ ‡ç­¾
                overlayCtx.fillStyle = boxColor;
                overlayCtx.font = 'bold 20px Arial';
                overlayCtx.fillText(gestureDetected, boxX, boxY - 20);
              }

              setCurrentGesture(gestureDetected);
              setGestureColor(boxColor);
            } else {
              setHandDetected(false);
              setCurrentGesture('ç­‰å¾…æ‰‹åŠ¿...');
              setGestureColor('#666');
              lastX = null;
            }
          });

          if (videoRef.current) {
            const camera = new window.Camera(videoRef.current, {
              onFrame: async () => {
                if (videoRef.current) {
                  await hands.send({ image: videoRef.current });
                }
              },
              width: 640,
              height: 480,
            });
            camera.start();
          }
        } catch (err) {
          console.error('Hand tracking error:', err);
          setCameraError('æ‰‹åŠ¿è¯†åˆ«åˆå§‹åŒ–å¤±è´¥');
        }
      };

      // SVG å›¾æ ‡ç»„ä»¶
      const CameraIcon = () => (
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
          <path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/>
          <circle cx="12" cy="13" r="3"/>
        </svg>
      );

      const HandIcon = () => (
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
          <path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0"/>
          <path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2"/>
          <path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8"/>
          <path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/>
        </svg>
      );

      const ZapIcon = () => (
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
          <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/>
        </svg>
      );

      const Volume2Icon = () => (
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
          <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
          <path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>
          <path d="M19.07 4.93a10 10 0 0 1 0 14.14"/>
        </svg>
      );

      const VolumeXIcon = () => (
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
          <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
          <line x1="23" y1="9" x2="17" y2="15"/>
          <line x1="17" y1="9" x2="23" y2="15"/>
        </svg>
      );

      return (
        <div className="min-h-screen bg-gray-900 flex items-center justify-center p-4">
          <div className="max-w-6xl w-full">
            <div className="text-center mb-6">
              <h1 className="text-4xl font-bold text-white mb-2">æ‰‹åŠ¿æ§åˆ¶ç‰¹æ•ˆæ–¹å—æ¸¸æˆ</h1>
              <p className="text-gray-400">é”®ç›˜: â†â†’ ç§»åŠ¨ | â†‘ æ—‹è½¬ | â†“ å¿«é€Ÿä¸‹è½</p>
              <p className="text-gray-400">æ‰‹åŠ¿: å·¦å³ç§»åŠ¨æ‰‹æŒ | æ‰‹æŒä¸Šä¸¾æ—‹è½¬ | æåˆå¿«é€Ÿä¸‹è½</p>
            </div>

            <div className="flex flex-col lg:flex-row gap-6 items-start justify-center">
              <div className="relative">
                <canvas
                  ref={canvasRef}
                  className="border-4 border-purple-500 rounded-lg shadow-2xl"
                  style={{ boxShadow: '0 0 50px rgba(139, 92, 246, 0.5)' }}
                />
                <div className="absolute top-4 left-4 bg-black bg-opacity-70 px-4 py-2 rounded">
                  <div className="text-yellow-400 text-2xl font-bold">å¾—åˆ†: {score}</div>
                </div>
                <div className="absolute top-4 right-4 flex gap-2">
                  <button
                    onClick={() => setSoundEnabled(!soundEnabled)}
                    className="bg-black bg-opacity-70 p-2 rounded hover:bg-opacity-90"
                  >
                    {soundEnabled ? 
                      <Volume2Icon /> : 
                      <VolumeXIcon />
                    }
                  </button>
                </div>
              </div>

              <div className="bg-gray-800 rounded-lg p-6 w-full lg:w-96">
                <h2 className="text-white text-xl font-bold mb-4 flex items-center gap-2">
                  <HandIcon />
                  æ‰‹åŠ¿æ§åˆ¶
                </h2>

                {!cameraActive ? (
                  <div>
                    <button
                      onClick={startCamera}
                      className="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg flex items-center justify-center gap-2 transition"
                    >
                      <CameraIcon />
                      å¯åŠ¨æ‘„åƒå¤´
                    </button>
                    {cameraError && (
                      <div className="mt-4 p-3 bg-red-900 bg-opacity-50 rounded text-red-200 text-sm">
                        {cameraError}
                      </div>
                    )}
                  </div>
                ) : (
                  <div>
                    <div className="relative w-full rounded-lg mb-4 overflow-hidden" style={{ aspectRatio: '4/3' }}>
                      <video
                        ref={videoRef}
                        className="absolute inset-0 w-full h-full object-cover"
                        style={{ transform: 'scaleX(-1)' }}
                        playsInline
                        muted
                      />
                      <canvas
                        ref={overlayCanvasRef}
                        className="absolute inset-0 w-full h-full"
                        style={{ transform: 'scaleX(-1)' }}
                      />
                    </div>
                    
                    <div className={`flex items-center gap-2 p-3 rounded mb-3 ${handDetected ? 'bg-green-900' : 'bg-red-900'}`}>
                      <ZapIcon />
                      <span className="text-white">{handDetected ? 'æ‰‹åŠ¿å·²è¯†åˆ«' : 'æœªæ£€æµ‹åˆ°æ‰‹åŠ¿'}</span>
                    </div>

                    <div className="p-3 rounded" style={{ backgroundColor: gestureColor + '33', borderLeft: `4px solid ${gestureColor}` }}>
                      <div className="text-sm text-gray-300">å½“å‰åŠ¨ä½œ:</div>
                      <div className="text-lg font-bold" style={{ color: gestureColor }}>
                        {currentGesture}
                      </div>
                    </div>
                  </div>
                )}

                <div className="mt-6 text-gray-300 text-sm space-y-2">
                  <p className="font-bold text-white">æ‰‹åŠ¿è¯´æ˜:</p>
                  <p>ğŸ”µ å·¦å³ç§»åŠ¨æ‰‹æŒ â†’ æ–¹å—ç§»åŠ¨</p>
                  <p>ğŸŸ¡ æ‰‹æŒä¸Šä¸¾ â†’ æ—‹è½¬æ–¹å—</p>
                  <p>ğŸŸ£ æåˆæ‰‹æŒ‡ â†’ å¿«é€Ÿä¸‹è½</p>
                </div>
              </div>
            </div>

            <div className="mt-8 text-center text-gray-400 text-sm">
              <p>ä½¿ç”¨ React, MediaPipe Hands å’Œ Web Audio API æ„å»º</p>
              <p className="mt-2">âœ¨ å®æ—¶æ‰‹éƒ¨è¿½è¸ªå¯è§†åŒ– | å½©è‰²è¾¹ç•Œæ¡†è¡¨ç¤ºä¸åŒæ‰‹åŠ¿</p>
            </div>
          </div>
        </div>
      );
    };

    ReactDOM.render(<GestureTetrisGame />, document.getElementById('root'));
  </script>
</body>
</html>
